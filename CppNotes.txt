Best Practices Only:
1_Basics.cpp
    Brace initialization gives better performance compared to normal initialization.
    \n is better than endl.
    Use snake case or camel case for variable names.
2_Functions.cpp
    Nested functions are not supported in c++. Error on line 5.
    Note the line no. 23 i.e same as int num = getValueFromUser();
3_ForwardDec.cpp
    It is also called as function prototyping or forward declaration.
    Like in line no. 3, it is best to forward declare it with the parameters and to not do just int add(int, int);
4_BasicsAboutNamespaces.cpp
    As u can see, there is ambiguity when using namespace std, because compiler doesn't know if it should call the 
    namespace or the function.
5_Macro.cpp
    Macros are resolved before compilation, that's why they're faster. Also called preprocessors. #include is a preprocessors
    and iostream is a header file.
    Three things you've to know in this is #define, #ifdef and #ifndef
    #define is self-explanatory
    #ifdef is basically if it is defined, execute code inside that block.
    #ifndef is basically if it is not defined, execute code inside that block.
6_HeaderFilesAndHeaderGuards Folder
    Always include header guards.
    Do not define variables and functions in header files.
    Give your header files the same name as the source files theyâ€™re associated with (e.g. grades.h is paired with grades.cpp).
    Do not #include .cpp files.
    Also, as you can see in those 3 files, thanks to header guards in .h file and even if you #include "square.h"
    in the other two files, it doesn't get included more than once.
    Anyway #include "square.h" in those two .cpp files are for those files to access the functions.
    To run it do, g++ main.cpp square.cpp (i.e add all the .cpp files)
7_ConstAndConstExp.cpp
    const datatype variable_name is the syntax for best practice.(line 4)
    From line 5 we can see that const variable has to be declared and initialized, otherwise error.
    We usually, make function parameters as const, obviously this doesn't makes sense when it is pass by value,
    because in pass by value a copy is passed, so even if you change the value, it doesn't matter.
    const vs constexpr is, const should be declared if the variable doesn't change during run time.
    constexpr should be declared if the variable doesn't change during compile time.
    Using constexp over macros is a best practice because, debugger can't find a macro, but it can find a constexp.
    constexpr can't be forward declared.
8_MoreAboutNamespace.cpp
    Namespaces are used to avoid naming collisions.
    Types:user-defined and global.
    global namespace are those that are provided by the compiler like std
    user-defined are the ones defined by user like goo and foo.
    Namespace aliasing example:   namespace boo = foo::goo;(goo is a namespace inside foo)
    Use namespaces when you are distributing code also, as you may or may not have followed good conventions in your
    code, so that might cause conflicts with other functions.
9_Auto.cpp
    Auto is also called type reference.
    Best practice is to not use auto for function return type
    Best to do it like line no.4
10_StaticCast.cpp
    static_cast needs the datatype it needs to convert to.
11_AnonymousAndInlineNamespace.cpp
    Anonymous namespaces are also called unnamed namespace.
    The Anonymous namespace declared in that file is available only in that file.
    You would create an inline namespace for the same purpose.
12_Strings.cpp
    line no.5 gives error for some reason.
    only while declaration and initialization brace initialization seems to be fine, while re-initialization it is giving
    error.
    cin is useless when the string contains whitespaces, it only reads until space.
    use getline instead.
13_Enum.cpp
    enums are used for code readability.